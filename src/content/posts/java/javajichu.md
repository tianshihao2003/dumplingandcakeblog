---

title: Java基础  
published: 2026-02-06  
description: 记录Java基础学习笔记。  
image: "https://re.tsh520.cn/img/001.webp"  
tags: [java]  
category: "编程学习"

---

# Java概述

Java 语言是面向对象的(oop)、有跨平台性（一次编译到处运行）

Java 技术体系平台

- JavaSE（Java Standard Edition）标准版
- Java EE(Java Enterprise Edition）企业版
- Java ME(Java Micro Edition)小型版

Java 语言是解释型的

- 解释性语言：javascript，PHP，java
- 编译性语言:c/ c++

  - 区别是：解释性语言，编译后的代码。不能直接被机器执行,需要解释器来执行，  
                    编译性语言，编译后的代码，可以直接被机器执行，c/c++

Java 核心机制-Java 虚拟机 [JVM java virtual machine]

基本介绍：JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK 中。对于不同的平台，有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行“。

什么是JDK，JRE

- JDK = JRE + 开发工具集（例如 Javac,java 编译工具等)
- JRE = JVM+ Java SE 标准类库（java 核心类库）
- 如果只想运行开发好的.class 文件 只需要 JRE

javac ：命令对该 java 文件进行编译， 生成 .class 文件。  
java   ： 命令对生成的 class 文件进行运行

Java常用转义字符

|转义序列|含义|描述|
| :---------| :-------| :----------------------------------------------------------------------------|
|​`\'`|单引号|用于在字符常量`' '`或字符串中包含单引号。|
|​`\"`|双引号|用于在字符串`" "`中包含双引号。|
|​`\\`|反斜杠|表示一个实际的反斜杠字符`\`。|
|​`\n`|换行符|将光标移动到下一行的开头（Line Feed）。|
|​`\r`|回车符|将光标移动到当前行的开头（Carriage Return）。<br /> *(注：Windows 换行通常是*​ *​`\r\n`​*​ *，Unix/Linux/macOS 通常是*​ *​`\n`​*​ *)*|
|​`\t`|制表符|插入一个水平制表符（Tab），通常相当于 4 或 8 个空格。|
|​`\b`|退格符|将光标向后移动一格（Backspace）。|
|​`\f`|换页符|用于打印机控制，表示换页（Form Feed）。|
|​`\0`|空字符|ASCII 码为 0 的字符（Null），常用于 C 风格字符串结尾，Java 中较少直接使用。|

初学java易犯错误

- 找不到文件：源文件名不存在或者写错，或者当前路径错误
- 主类名和文件名不一致：声明为public的主类应与文件名一致，否知编译失败
- 缺少分号：编译失败，注意错误出现的行数，再到源代码中指定位置改错。

注释

- 单行注释 //
- 多行注释 /* */
- 文档注释 /** */

‍

# 变量

变量的注意事项：

- 变量表示内存中的一个存储区域不同的变量，类型不同，占用的空间大小不同
- 变量必须先声明，后使用，即有顺序
- 变量在同一个作用域内不能重名
- 变量=变量名+值+数据类型，这一点请大家注意。变量三要素

## 数据类型

基本数据类型：

|类型|关键字|位数 (bit)|字节 (byte)|取值范围|默认值|说明|
| :-------| :-------| :-----------| :------------| :-------------------------------| :-------| :---------------------------------|
|整数型|​`byte`|8|1|-128 \~ 127|​`0`|最小整数类型，常用于节省内存数组|
||​`short`|16|2|-32,768 \~ 32,767|​`0`|较少使用|
||​`int`|32|4|-2³¹ \~ 2³¹-1|​`0`|最常用的整数类型|
||​`long`|64|8|-2⁶³ \~ 2⁶³-1|​`0L`|用于大整数，字面量需加`L`|
|浮点型|​`float`|32|4|约 ±3.4E38 (7位有效数字)|​`0.0f`|单精度，字面量需加`F`|
||​`double`|64|8|约 ±1.8E308 (15-17位有效数字)|​`0.0d`|最常用的浮点类型|
|字符型|​`char`|16|2|​`\u0000`​\~`\uffff`​(0 \~ 65535)|​`'\u0000'`|存储单个 Unicode 字符|
|布尔型|​`boolean`|-|-|​`true`​或`false`|​`false`|仅用于逻辑判断，大小由 JVM 决定|

java数据类型分为两大类基本数据类型，引用类型

- 基本数据类型有8种：  
  数值型：[byte,short,int,long,float,double]  
  字符型：char  
  布尔型：boolean
- 引用类型[类，接口，数组]

## JavaAPI文档

网站：

- https://www.oracle.com/cn/java/technologies/java-se-api-doc.html
- https://www.matools.com

[下载](https://gitcode.com/open-source-toolkit/23aa4/blob/main/Java%20API%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%89%88.zip)

‍

## 基本数据类型转换

自动类型转换

- 规则：byte → short → char → int → long → float → double
- ```java
  byte → short → int → long → float → double
         ↘ char ↗
  ```
- 细节：

  - 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
  - 当我们把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换。
  - （byte，short）和char之间不会相互自动转换。
  - byte，short，char 他们三者可以计算，在计算时首先转换为int类型。
  - boolean不参与转换
  - 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型

强制类型转换

- 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符（)，但可能造成**精度降低或溢出**，格外要注意。
- ```java
  目标类型 变量名 = (目标类型) 原值;
  ```
- 细节：当进行数据的大小从大一一>小，就需要使用到强制转换
- 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级
- char类型可以保存int的常量值，但不能保存int的变量值，需要强转
- byte和short，char类型在进行运算时，当做int类型处理。

## 基本数据类型和 String 类型的转换

基本类型转String类型  
语法：将基本类型的值+即可

String类型转基本数据类型【体验】  
语法：通过基本类型的包装类调用parseXX方法即可

# 运算符

算术运算符、赋值运算符、关系运算符 [比较运算符]、逻辑运算符、位运算符 [需要二进制基础]、三元运算符

## 算数运算符

|运算符|运算|范围|结果|
| --------| ----------------------------------------------------| ----------------------------------------| ----------------------------------|
|+|正号|+7|7|
|-|负号|b\=11; -b|-11|
|+|加|9+9|18|
|-|减|10-8|2|
|\*|乘|7\*8|56|
|/|除|9/9|1|
|%|取模(取余)|11%9|2|
|++|自增（前）：先运算后取值<br />自增（后）：先取值后运算|a\=2;b\=++a;<br />a\=2;b\=a++;|a\=3;b\=3<br />a\=3;b\=2|
|--|自减（前）：先运算后取值<br />自减（后）：先取值后运算|a\=2;b\=--a;<br />a\=2;b\=a--;|a\=1;b\=1<br />a\=1;b\=2|
|+|字符串相加|"hsp"+"edu"|"hsp edu"|

细节说明：

1. **对于除号 "/"，它的整数除和小数除是有区别的**
2. **当对一个数取模时，可以等价表示为：**​`a % b = a - (a / b) * b`

   示例：`11 % 9 = 11 - (11/9)*9 = 11 - 1*9 = 2`
3. **当自增当做一个独立语句使用时，不管是**  **​`++i;`​** ​ **还是** **​`i++;`​** ​ **都是一样的，等价于：** → `i = i + 1;`
4. **当自增当做一个表达式使用时，**   
   ​**​`j = ++i`​**​ **等价于：** → `i = i + 1; j = i;`​  
   ​**​`j = i++`​** ​ **等价于：** → `j = i; i = i + 1;`

## 关系运算符

|运算符|运算|范例|结果|
| --------| --------------------| -------------------------| -------|
|==|相等于|8 == 7|false|
|!=|不等于|8 != 7|true|
|<|小于|8 < 7|false|
|>|大于|8 > 7|true|
|<=|小于等于|8 <= 7|false|
|>=|大于等于|8 >= 7|true|
|​`instanceof`|检查是否是类的对象|"hsp" instanceof String|true|

细节说明：

1. 关系运算符的`结果`都是boolean 型，也就是要么是 true，要么是 false。
2. 关系运算符组成的表达式，我们称为关系表达式。a>b
3. 比较运算符"=="不能误写成"="

## 逻辑运算符

|a|b|a & b|a && b|a \| b|a \|\| b|!a|a \^ b|
| -------| -------| -------| --------| -----------| ----------------| -------| -----------|
|true|true|true|true|true|true|false|false|
|true|false|false|false|true|true|false|true|
|false|true|false|false|true|true|true|true|
|false|false|false|false|false|false|true|false|

|运算符|名称|类型|说明|
| --------| -----------------| -------------| -------------------------------------------|
|​`&`|按位与 / 逻辑与|位运算/逻辑|两边都为 true 才返回 true；无短路|
|​`&&`|短路与|逻辑运算|左边为 false 时右边不执行，直接返回 false|
|​`\|`|按位或 / 逻辑或|位运算/逻辑|任一边为 true 就返回 true；无短路|
|​`\|\|`|短路或|逻辑运算|左边为 true 时右边不执行，直接返回 true|
|​`!`|非|逻辑运算|取反|
|​`^`|异或|位运算/逻辑|两边不同为 true，相同为 false|

💡 注意：

虽然 `&`​, `|`​, `^`​ 可用于布尔值作逻辑运算，但它们也常用于整数的**位运算**。

而 `&&`​, `||` 仅用于布尔逻辑，且具有“短路”特性。

📌 **记忆口诀：**

“与要全真才为真，或有一真即为真；  
非是取反很简单，异或不同才是真；  
短路运算效率高，左边决定右不跑！”

## 赋值运算符

|运算符|名称|
| ----------------------| ------------------|
|\=|基本赋值|
|+\=|加后赋值|
|-\=|减后赋值|
|\*\=|乘后赋值|
|/\=|除后赋值|
|%\=|取模后赋值|
|&\=|按位与后赋值|
|\|\=|按位或后赋值|
|\^\=|按位异或后赋值|
|\<\<\=|左移后赋值|
|\>\>\=|右移后赋值|
|\>\>\>\=|无符号右移后赋值|

## 三元运算符

条件表达式 ? 表达式 1: 表达式 2;

运算规则：

1. 如果条件表达式为 true， 运算后的结果是表达式 1；
2. 如果条件表达式为 false， 运算后的结果是表达式 2；

## 运算符优先级（熟悉即可）

|优先级|运算符|类型|结合性|示例|
| --------| ---------------------------------------| --------------------------------------------------| ----------| ---------------|
|1|​`()`​ `[]`​ `.`|括号、数组索引、成员访问|左 → 右|​`obj.method()`​,`arr[0]`|
|2|​`expr++`​ `expr--`|后缀自增/自减|左 → 右|​`i++`​,`count--`|
|3|​`++expr`​ `--expr`​ `+`​ `-`​ `~`​ `!`​ `(type)`|前缀操作符、正负号、按位非、逻辑非、强制类型转换|右 → 左|​`++i`​,`-x`​,`!flag`​,`(int)y`|
|4|​`*`​ `/`​ `%`|乘、除、取模|左 → 右|​`a * b`​,`x % 3`|
|5|​`+`​ `-`|加、减|左 → 右|​`a + b`​,`x - 1`|
|6|​`<<`​ `>>`​ `>>>`|移位运算|左 → 右|​`x << 2`​,`y >>> 1`|
|7|​`<`​ `>`​ `<=`​ `>=`​ `instanceof`|关系运算|左 → 右|​`a > b`​,`obj instanceof Class`|
|8|​`==`​ `!=`|相等性判断|左 → 右|​`x == 5`​,`a != b`|
|9|​`&`|按位与|左 → 右|​`a & b`|
|10|​`^`|按位异或|左 → 右|​`a ^ b`|
|11|​`\|`|按位或|左 → 右|​`a \| b`|
|12|​`&&`|逻辑与|左 → 右|​`a && b`|
|13|​`\|\|`|逻辑或|左 → 右|​`a \|\| b`|
|14|​`? :`|三元条件运算符|右 → 左|​`cond ? a : b`|
|15|​`=`​ `+=`​ `-=`​ `*=`​ `/=`​ `%=`​ `&=`​ `^=`​ `\|=`​ `<<=`​ `>>=`​ `>>>=`|赋值运算|右 → 左|​`x = 5`​,`sum += i`|

## 标识符命名规则和规范

标识符概念：

1. Java 对各种变量、方法和类等命名时使用的字符序列称为标识符
2. 凡是自己可以起名字的地方都叫标识符intnum1=90;

标识符的命名规则（必须遵守）

- 只能包含：**字母**（A-Z, a-z）、**数字**（0-9）、**下划线**（`_`​）和 **美元符号**（`$`）。
- **不能以数字开头，** 不可以使用关键字和保留字，但能包含关键字和保留字。
- 标识符不能包含空格。**长度没有限制**

软性规范（行业最佳实践）

命名风格（驼峰命名法）

1. 大驼峰命名法：类名、接口名、枚举名、注解名
2. 小驼峰命名法：方法名、变量名、参数名
3. 常量名：全大写 + 下划线分隔
4. 包名 (Package)：全小写 + 点号分隔

特殊场景规范

1. 测试类：通常以被测试类名 + `Test` 结尾
2. 异常类：以 `Exception`​ 或 `Error` 结尾
3. 实现类：若接口名为 `XxxService`​，实现类通常为 `XxxServiceImpl`

# Java相关基础知识

## 进制

二进制：0,1，满2进1.以0b 或0B 开头

十进制：0-9，满10进1

八进制：0-7，满8进1．以数字0开头表示

十六进制：0-9 及 A(10)-F(15)，满16 进1．以0x或0X开头表示。此处的 A-F 不区分大小写

进制的转换

1. 二进制转十进制：  
   规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和。  
   案例：0b1011 → 十进制

   ```java
   0b1011 = 
   = 1*1 + 1*2 + 0*4 + 1*8 
   = 1 + 2 + 0 + 8 = 11
   ```

2. 八进制转十进制：  
   规则：从最低位(右边)开始，将每个位上的数提取出来，乘以8的(位数-1)次方，然后求和。  
   案例：0234 → 十进制

   ```java
   0b1011 = 
   = 1*1 + 1*2 + 0*4 + 1*8 
   = 1 + 2 + 0 + 8 = 11
   ```

3. 十六进制转十进制：  
   规则：从最低位(右边)开始，将每个位上的数提取出来，乘以16的(位数-1)次方，然后求和。  
   案例：0x1A3 → 十进制

   ```java
   0x1A3 =
   = 3×16⁰ + A×16¹ + 1×16²
   = 3×1 + 10×16 + 1×256 = 3 + 160 + 256 = 419
   ```

4. 十进制 → 二进制  
   规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。  
   案例：将 `34` 转成二进制

   ```
   2 | 34  ... 0  ← 余数
   2 | 17  ... 1
   2 |  8  ... 0
   2 |  4  ... 0
   2 |  2  ... 0
   2 |  1  ... 1
     |  0
   ```

   将余数**从下往上**倒序排列：`100010`

5. 十进制 → 八进制  
   **规则**：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。  
   **案例**：将 `131` 转成八进制

   ```
   8 | 131 ... 3  ← 余数
   8 |  16 ... 0
   8 |   2 ... 2
     |   0
   ```

   将余数**从下往上**倒序排列：`203`
6. 十进制 → 十六进制  
   **规则**：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。  
   **案例**：将 `237` 转成十六进制

   ```
   16 | 237 ... 13 (D)  ← 余数
   16 |  14 ... 14 (E)
      |   0
   ```

   将余数**从下往上**倒序排列：`ED`

## 原码、反码、补码（重点 · 难点）

> **核心结论（背诵）** ：针对有符号数

1. **符号位**：二进制最高位是符号位，`0`​ 表示正数，`1`​ 表示负数（口诀：`0->+`​, `1->-`）。
2. **正数**：原码、反码、补码 **三码合一**。
3. **负数**：

   - 反码 = 原码符号位不变，其余位取反（`0->1`​, `1->0`）。
   - 补码 = 反码 + 1；反码 = 补码 - 1。
4. **零**：`0`​ 的反码、补码都是 `0`。
5. **Java 特性**：Java 没有无符号数，所有数都是有符号的。
6. **运算本质**：计算机内部以**补码**进行运算。
7. **结果查看**：最终结果需转换为**原码**查看。

## 位运算符

Java 中位运算符包含：`&`​、`|`​、`^`​、`~`​、`>>`​、`<<`​、`>>>`，共 7 个。

|运算符|名称|运算规则|
| --------| ----------| --------------------------------------------|
|​`&`|按位与|两位全为 `1`​，结果为 `1`​；否则为 `0`|
|​`` ` ``|​`` ` ``|按位或|
|​`^`|按位异或|两位不同（`0`​ 和 `1`​），结果为 `1`​；否则为 `0`|
|​`~`|按位取反|​`0`​ 变 `1`​，`1`​ 变 `0`|

### 位移运算（共 3 种）

|运算符|名称|运算规则|
| --------| ----------| --------------------------------------|
|​`>>`|算术右移|低位溢出，符号位不变，用符号位补高位|
|​`<<`|算术左移|符号位不变，低位补 `0`|
|​`>>>`|逻辑右移|（无符号右移）低位溢出，高位补 `0`|

> **特别说明**：Java 中 **不存在** `<<<` 符号。

案例

1. ​`int a = 1 >> 2;`

   - 二进制：`1`​ → `00000001`
   - 右移 2 位：`00000001`​ → `00000000`
   - 数学本质：`1 / 2 / 2 = 0`
   - 结果：`a = 0`
2. ​`int c = 1 << 2;`

   - 二进制：`1`​ → `00000001`
   - 左移 2 位：`00000001`​ → `00000100`
   - 数学本质：`1 * 2 * 2 = 4`
   - 结果：`c = 4`

# 程序控制结构

1. ​**顺序控制**：程序默认的、线性的执行方式。
2. ​**分支控制**：根据条件选择性地执行代码。
3. ​**循环控制**：让特定代码重复执行。

## 分支控制

### 1. 顺序控制

- 程序从上到下逐行执行，是最基本的流程。

### 2. 单分支 if

- ​**语法**：

```java
if (条件表达式) {
    // 条件为 true 时执行的代码块
}
```

- ​**说明**：当条件表达式为 true 时，执行 {} 内的代码。建议即使只有一条语句也使用 {}。

### 3. 双分支 if-else

- ​**语法**：

```java
if (条件表达式) {
    // 条件为 true 时执行的代码块1
} else {
    // 条件为 false 时执行的代码块2
}
```

- ​**流程图**：条件 → (true) 执行代码块1 → 继续 / (false) 执行代码块2 → 继续。

### 4. 多分支 if-else if-...-else

- ​**语法**：

```java
if (条件表达式1) {
    // 执行代码块1
} else if (条件表达式2) {
    // 执行代码块2
} 
// ... 可以有多个 else if
else {
    // 所有条件都不满足时执行的代码块n
}
```

- ​**关键点**：

  1. 从上到下依次判断条件，一旦某个条件为 true，则执行对应的代码块，然后**直接跳出**整个多分支结构。
  2. 可以没有 else。如果没有 else 且所有条件都不成立，则没有任何代码块被执行。

### 5. 嵌套分支

- ​**概念**：在一个分支结构中完整地嵌套另一个分支结构。
- ​**建议**：嵌套层次不宜过多（通常不超过3层），否则影响代码可读性。

### 6. switch 分支结构

- ​**语法**：

```java
switch (表达式) {
    case 常量1:
        语句块1;
        break;
    case 常量2:
        语句块2;
        break;
    ...
    default:
        default语句块;
        break;
}
```

- ​**执行流程**：

  1. 计算表达式的值。
  2. 将其值与 case 后的常量依次比较。
  3. 如果匹配，则执行对应的语句块，直到遇到 break 或 switch 结束。
  4. 如果没有匹配的 case，则执行 default 语句块（如果存在）。
- ​**注意事项**：

  1. ​**表达式类型**：必须是 byte, short, int, char, 枚举(enum), String。
  2. ​**case 值**：必须是常量，不能是变量。
  3. ​**default**：是可选的。位置是灵活的。
  4. ​**break**​：用于跳出 switch 块。如果没有 break，程序会**穿透**执行后续 case 的语句块，直到遇到 break 或结束。
- **switch 与** ​​**if 的比较**：

  - 判断的具体数值不多，且符合上述6种类型时，建议用 switch（效率高、结构清晰）。
  - 对区间进行判断，或判断结果为 boolean 类型时，使用 if。if 适用范围更广。

## 循环控制

### 1. for 循环

- ​**语法**：

```java
for (循环变量初始化; 循环条件; 循环变量迭代) {
    循环操作(语句);
}
```

- ​**循环四要素**：①初始化 ②条件 ③操作 ④迭代。
- ​**执行流程**：初始化 → 判断条件 (true) → 执行循环体 → 执行迭代 → 再次判断条件...
- ​**细节**：

  - 初始化、迭代部分可以写在别处（分号不能省），也可以有多条同类型语句，用逗号隔开（如 for(int i\=0,j\=0; i\<5; i++, j+\=2)）。

### 2. while 循环

- ​**语法**：

```java
循环变量初始化;
while (循环条件) {
    循环体(语句);
    循环变量迭代;
}
```

- ​**特点**​：​**先判断，再执行**。四要素位置与 for 不同。

### 3. do...while 循环

- ​**语法**：

```java
循环变量初始化;
do {
    循环体(语句);
    循环变量迭代;
} while (循环条件);
```

- ​**特点**​：​**先执行一次循环体，再判断条件**。至少执行一次。结尾有分号;。
- **与 while**​​ **的区别**：do...while 至少执行一次，while 可能一次都不执行。

### 4. 多重循环（嵌套循环）

- ​**概念**：一个循环体内包含另一个完整的循环结构。
- ​**建议**：一般使用两层，最多不超过三层。
- ​**执行次数**​：外层循环 m 次，内层循环 n 次，则内层循环体实际执行 m \* n 次。

## 跳转控制语句

### 1. break

- ​**作用**：用于终止某个语句块的执行。常用于 switch 和循环结构中，提前结束循环。
- ​**带标签的break**：可以指定跳出多层嵌套中的某一层。

```java
label1: for(...) {
    label2: for(...) {
        if(...) {
            break label1; // 直接跳出外层label1的循环
        }
    }
}
```

### 2. continue

- ​**作用**​：结束**本次**循环，跳过剩余语句，直接进行下一次循环的迭代判断。
- ​**带标签的continue**：可以指定跳过多层嵌套中某一层的本次循环。
- ​**课堂练习**：使用 continue 跳过特定迭代。

### 3. return

- ​**作用**：用于方法中，表示跳出所在的方法。如果用在 main 方法中，则退出程序。

‍

# 数组排序和查找

- **问题引入**：当需要处理大量同类型数据时
- ​**数组作用**​：数组是一种​**引用类型**​，可以存放**多个同一类型**的数据，实现对数据的统一管理。

- ​**定义与初始化**：

```java
double[] hens = {3, 5, 1, 3.4, 2, 50}; // 静态初始化
```

- ​**访问元素**：通过数组名[下标]访问，下标从0开始。例如hens[0]是第一个元素。
- ​**获取长度**：数组名.length。
- ​**遍历**：使用for循环。

```java
for(int i = 0; i < hens.length; i++) {
    totalWeight += hens[i];
}
```

## 数组的使用

- ​**动态初始化1**：声明并直接分配空间。

```java
int[] a = new int[5]; // 创建可存放5个int的数组
```

- ​**动态初始化2**：先声明，再分配空间。

```java
int[] a; // 声明
a = new int[5]; // 分配空间
```

- ​**静态初始化**：声明的同时赋值。

```java
int[] arr = {1, 2, 3, 4, 5};
```

### 注意事项与细节

1. ​**类型一致**：数组元素必须是相同类型（基本或引用类型），不能混用。
2. ​**默认值**：数组创建后未赋值，有默认值（int为0，double为0.0，boolean为false，String等引用类型为null）。
3. ​**使用步骤**​：①声明并开辟空间 -\> ②赋值 -\> ③使用。
4. ​**下标范围**：下标从0开始，有效范围为 [0, length-1]。使用超出范围的下标会导致“下标越界异常”。
5. ​**引用类型**：数组是引用类型，数组变量存储的是地址。

## 数组应用案例

1. ​**创建字符数组**：存放‘A’到‘Z’。

```java
char[] chars = new char[26];
for(int i = 0; i < chars.length; i++) {
    chars[i] = (char)('A' + i); // ‘A’+1 得到 ‘B’
}
```

2. ​**求数组最大值及下标**：假定第一个元素为最大值，遍历比较并更新。
3. ​**求数组和与平均值**：遍历累加。

## 数组赋值机制与内存

1. ​**基本数据类型赋值**：传递的是值本身，变量独立。
2. ​**数组赋值（引用传递）** ：传递的是地址，多个变量可指向同一个数组对象。

```java
int[] arr1 = {1, 2, 3};
int[] arr2 = arr1; // arr2 和 arr1 指向同一数据空间
arr2[0] = 100; // arr1[0] 也变为 100
```

## 数组常见操作

### 1. 数组拷贝

- ​**要求**：创建新数组，数据空间独立。
- ​**方法**：创建新数组，遍历拷贝。

```java
int[] arr2 = new int[arr1.length];
for(int i = 0; i < arr1.length; i++) {
    arr2[i] = arr1[i];
}
```

### 2. 数组反转

- ​**方法一（原地交换）** ：首尾对应元素交换。

```java
for(int i = 0; i < arr.length / 2; i++) {
    int temp = arr[i];
    arr[i] = arr[arr.length - 1 - i];
    arr[arr.length - 1 - i] = temp;
}
```

- ​**方法二（逆序赋值）** ：创建新数组，逆序遍历原数组进行赋值，最后让原数组引用指向新数组。

### 3. 数组添加/扩容

- ​**思路**：

  1. 创建新数组，大小为 原长度 + 1。
  2. 遍历原数组，拷贝元素到新数组。
  3. 将新元素放入新数组末尾。
  4. 让原数组变量指向新数组（原数组空间被垃圾回收）。
- ​**实现**：结合Scanner和do...while循环，实现用户交互式动态扩容。

### 4. 数组缩减

- ​**思路**：与扩容类似，创建更小的新数组拷贝部分元素，并提示用户直到无法缩减。

## 排序

### 1. 排序介绍

- ​**内部排序**：数据全部加载到内存中排序（如冒泡、选择、插入排序）。
- ​**外部排序**：数据量过大，需借助外部存储排序。

### 2. 冒泡排序

- ​**基本思想**：从后向前，依次比较相邻元素，逆序则交换，使大值逐渐后移。
- ​**案例**：将 {24,69,80,57,13} 排成升序。
- ​**代码实现**：

```java
for(int i = 0; i < arr.length - 1; i++) { // 外层控制轮数
    for(int j = 0; j < arr.length - 1 - i; j++) { // 内层逐对比较
        if(arr[j] > arr[j+1]) {
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
```

## 查找

### 1. 顺序查找

- ​**方法**：遍历数组，逐一比较。
- ​**案例**：在字符串数组中查找输入的名称。

```java
int index = -1; // 使用索引变量，初始化为-1表示未找到
for(int i = 0; i < names.length; i++) {
    if(findName.equals(names[i])) {
        index = i;
        break;
    }
}
```

### 2. 二分查找

- ​**说明**​：针对**有序数组**的高效查找算法（文档中提及，详细讲解在算法部分）。

## 多维数组 - 二维数组

### 1. 快速入门

- ​**概念**：一维数组的每个元素又是一个一维数组，构成二维数组。
- ​**定义与初始化**：

```java
int[][] arr = {{0,0,0,0,0,0}, {0,0,1,0,0,0}, {0,2,0,3,0,0}, {0,0,0,0,0,0}};
```

- ​**访问元素**：arr[i][j] 表示第 i+1 个一维数组的第 j+1 个元素。
- ​**遍历**：双层for循环。

```java
for(int i = 0; i < arr.length; i++) { // 遍历行（每个一维数组）
    for(int j = 0; j < arr[i].length; j++) { // 遍历当前行的列
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
```

### 2. 使用方式

- ​**动态初始化1**​：int[][] arr \= new int[3]; // 2行3列
- ​**动态初始化2（列数不确定）** ：先确定行数，再分别为每一行分配不同列。

```java
int[][] arr = new int[]; // 3行，列未定
for(int i = 0; i < arr.length; i++) {
    arr[i] = new int[i + 1]; // 第i行有i+1列
}
```

- ​**静态初始化**​：int[][] arr \= {{1,2}, {3,4,5}, {6}};

### 3. 内存形式

- 二维数组变量（如arr）在栈中，指向堆中的一个地址，该地址存放的是多个引用，分别指向各个一维数组在堆中的实际数据空间。

### 4. 应用案例：杨辉三角

- ​**规律**：

  1. 第 i 行有 i+1 个元素。
  2. 每行首尾元素为 1。
  3. 非首尾元素：arr[i][j] \= arr[i-1][j] + arr[i-1][j-1]。

### 5. 细节与注意事项

- ​**声明方式**：int[][] y、int[] y[]、int y[][] 均可。
- ​**列数不等**：二维数组的各一维数组长度可以不同，构成“列数不等的二维数组”。

‍
